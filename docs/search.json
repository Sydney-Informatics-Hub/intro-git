[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SIH Introduction to version control using git",
    "section": "",
    "text": "This course is aimed at researchers, students, and industry professionals who want to learn about version controlling their code (or text files).\nThis course is adapted from Version Control with Git by staff from the Sydney Informatics Hub (Darya Vanichkina, …).\nAll materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "index.html#trainers",
    "href": "index.html#trainers",
    "title": "SIH Introduction to version control using git",
    "section": "Trainers",
    "text": "Trainers\n\nDarya Vanichkina (PhD Bioinformatics, SFHEA)\nKristian Maras (MSc Quant Fin)\nNathaniel (Nate) Butterworth (PhD Computational Geophysics)\nMichael Lynch (Research Software Engineering Group Lead)"
  },
  {
    "objectID": "index.html#course-pre-requisites-and-setup-requirements",
    "href": "index.html#course-pre-requisites-and-setup-requirements",
    "title": "SIH Introduction to version control using git",
    "section": "Course pre-requisites and setup requirements",
    "text": "Course pre-requisites and setup requirements\n\nNo previous programming experience is required.\nTraining will be delivered in-person, so you will need your own laptop with a stable internet connection and the ability to install your own software."
  },
  {
    "objectID": "index.html#code-of-conduct",
    "href": "index.html#code-of-conduct",
    "title": "SIH Introduction to version control using git",
    "section": "Code of Conduct",
    "text": "Code of Conduct\nWe expect all attendees of our training to follow our code of conduct, including bullying, harassment and discrimination prevention policies.\nIn order to foster a positive and professional learning environment we encourage the following kinds of behaviours at all our events and on our platforms:\n\nUse welcoming and inclusive language\nBe respectful of different viewpoints and experiences\nGracefully accept constructive criticism\nFocus on what is best for the community\nShow courtesy and respect towards other community members\n\nOur full CoC, with incident reporting guidelines, is available here."
  },
  {
    "objectID": "index.html#setup-instructions",
    "href": "index.html#setup-instructions",
    "title": "SIH Introduction to version control using git",
    "section": "Setup Instructions",
    "text": "Setup Instructions\nPlease complete the Setup Instructions before the course.\nIf you have any trouble, please get in contact with us via email ASAP."
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "Git is a version control system that lets you track who made changes to what when and has options for easily updating a shared or public version of your code on github.com.\n\nYou will need a supported web browser.\n\nPrior to the session, we recommend you use your “official” university email to create an account on github.com. You can skip this step if you already have a github.com and you know the username/password you used to log in to it. GitHub accounts are free, and - with your University affiliation - you may be able to get a “Pro” GitHub account for free (you need to email the GitHub Education team for this). Note that a free account will suffice for all of what we are doing in the training session, so you don’t need to do this before class. Please consider what personal information you’d like to reveal. For example, you may want to review these instructions for keeping your email address private provided at GitHub.\nAll materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "setup.html#install-git",
    "href": "setup.html#install-git",
    "title": "Setup",
    "section": "Install git",
    "text": "Install git\n\nWindows\n\nDownload the Git for Windows installer, also known as GitBash.\nRun the installer and follow the steps below:\n\nClick on “Next” four times (two times if you’ve previously installed Git). You don’t need to change anything in the Information, location, components, and start menu screens.\nFrom the dropdown menu, “Choosing the default editor used by Git”, select “Use the Vim editor by default” and click on “Next”.\nOn the page that says “Adjusting the name of the initial branch in new repositories”, ensure that “Let Git decide” is selected. This will ensure the highest level of compatibility for our lessons.\nEnsure that “Git from the command line and also from 3rd-party software” is selected and click on “Next”. (If you don’t do this Git Bash will not work properly, requiring you to remove the Git Bash installation, re-run the installer and to select the “Git from the command line and also from 3rd-party software” option.)\nSelect “Use bundled OpenSSH”.\nEnsure that “Use the native Windows Secure Channel Library” is selected and click on “Next”.\nEnsure that “Checkout Windows-style, commit Unix-style line endings” is selected and click on “Next”.\nEnsure that “Use Windows’ default console window” is selected and click on “Next”.\nEnsure that “Default (fast-forward or merge) is selected and click”Next”\nEnsure that “Git Credential Manager” is selected and click on “Next”.\nEnsure that “Enable file system caching” is selected and click on “Next”.\nClick on “Install”.\nClick on “Finish” or “Next”.\n\nIf your “HOME” environment variable is not set (or you don’t know what this is):\nOpen command prompt (Open Start Menu then type cmd and press Enter)\nType the following line into the command prompt window exactly as shown:\n\nsetx HOME \"%USERPROFILE%\"\n\nPress Enter, you should see SUCCESS: Specified value was saved.\nQuit command prompt by typing exit then pressing Enter\n\nThis will provide you with both Git and Bash in the Git Bash program.\n\n\n\nMacOS\nThe easiest way to install git on a Mac is by installing Xcode Command Line Tools (note: you do not need all of Xcode!, which takes a lot more space on your hard drive).\nTo do this, open your Terminal application and type:\ngit --version\nIf you don’t have git installed already, a popup will appear:\n\nPress on the blue “Install” button and, after entering your password, git should be installed.\n\n\n\nLinux\nDepending on the Linux distribution on your laptop, you will need to open a Terminal application and execute one of the following commands:\n\nDebian/Ubuntu\nFor the latest stable version for your release of Debian/Ubuntu\n# apt-get install git\nFor Ubuntu, this PPA provides the latest stable upstream Git version\n# add-apt-repository ppa:git-core/ppa``# apt update; apt install git\n\n\nFedora\n# yum install git (up to Fedora 21) # dnf install git (Fedora 22 and later)\n\n\nGentoo\n# emerge --ask --verbose dev-vcs/git\n\n\nArch Linux\n# pacman -S git\n\n\nopenSUSE\n# zypper install git\n\n\nMageia\n# urpmi git\n\n\nNix/NixOS\n# nix-env -i git\n\n\nFreeBSD\n# pkg install git\n\n\nSolaris 9/10/11\n# pkgutil -i git\n\n\nSolaris 11 Express\n# pkg install developer/versioning/git\n\n\nOpenBSD\n# pkg_add git"
  },
  {
    "objectID": "setup.html#optional-install-gitkraken",
    "href": "setup.html#optional-install-gitkraken",
    "title": "Setup",
    "section": "(Optional) Install GitKraken",
    "text": "(Optional) Install GitKraken\n\nWe will show but not necessarily walk through GitKraken, an excellent (but paid for!) Git GUI tool. When working on large, multi-branch open-source and internal projects, this type of a tool can be very useful to navigate the mess that a too-many branch workflow can create.\nGit is a free alternative developed by GitHub which you may want to use as a free GUI instead."
  },
  {
    "objectID": "notebooks/11_workflows.html",
    "href": "notebooks/11_workflows.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/05_history.html",
    "href": "notebooks/05_history.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/02_config.html",
    "href": "notebooks/02_config.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/07_github.html",
    "href": "notebooks/07_github.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/14_open_research.html",
    "href": "notebooks/14_open_research.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/06_ignore.html",
    "href": "notebooks/06_ignore.html",
    "title": "Ignoring Things",
    "section": "",
    "text": "mkdir results\ntouch a.dat b.dat c.dat results/a.out results/b.out\nand see what Git says:\ngit status\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    a.dat\n    b.dat\n    c.dat\n    results/\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nPutting these files under version control would be a waste of disk space. What’s worse, having them all listed could distract us from changes that actually matter, so let’s tell Git to ignore them.\nWe do this by creating a file in the root directory of our project called .gitignore:\nnano .gitignore\ncat .gitignore\n*.dat\nresults/\nThese patterns tell Git to ignore any file whose name ends in .dat and everything in the results directory.(If any of these files were already being tracked, Git would continue to track them.)\nOnce we have created this file, the output of git status is much cleaner:\n$ git status\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe only thing Git notices now is the newly-created .gitignore file. You might think we wouldn’t want to track it, but everyone we’re sharing our repository with will probably want to ignore the same things that we’re ignoring. Let’s add and commit .gitignore:\ngit add .gitignore\ngit commit -m \"Ignore data files and the results folder.\"\ngit status\nOn branch main\nnothing to commit, working directory clean\nAs a bonus, using .gitignore helps us avoid accidentally adding files to the repository that we don’t want to track:\ngit add a.dat\nThe following paths are ignored by one of your .gitignore files:\na.dat\nUse -f if you really want to add them.\nIf we really want to override our ignore settings, we can use git add -f to force Git to add something. For example, git add -f a.dat. We can also always see the status of ignored files if we want:\n$ git status --ignored\nOn branch main\nIgnored files:\n (use \"git add -f <file>...\" to include in what will be committed)\n\n        a.dat\n        b.dat\n        c.dat\n        results/\n\nnothing to commit, working directory clean\n\n\n\n\n\n\nIgnoring Nested Files\n\n\n\nGiven a directory structure that looks like:\nresults/data\nresults/plots\nHow would you ignore only results/plots and not results/data?\n\n\n\n\n\n\nSolution\n\n\n\nIf you only want to ignore the contents of results/plots, you can change your .gitignore to ignore only the /plots/ subfolder by adding the following line to your .gitignore:\nresults/plots/\nThis line will ensure only the contents of results/plots is ignored, and not the contents of results/data.\nAs with most programming issues, there are a few alternative ways that one may ensure this ignore rule is followed. The “Ignoring Nested Files: Variation” exercise has a slightly different directory structure that presents an alternative solution. Further, the discussion page has more detail on ignore rules.\n\n\n\n\n\n\n\n\n\n\nIncluding Specific Files\n\n\n\nHow would you ignore all .dat files in your root directory except for final.dat? Hint: Find out what ! (the exclamation point operator) does\n\n\n\n\n\n\nSolution\n\n\n\nYou would add the following two lines to your .gitignore:\n*.dat           # ignore all data files\n!final.dat      # except final.data\nThe exclamation point operator will include a previously excluded entry.\nNote also that because you’ve previously committed .dat files in this lesson they will not be ignored with this new rule. Only future additions of .dat files added to the root directory will be ignored.\n\n\n\n\n\n\n\n\n\n\nIgnoring Nested Files: Variation\n\n\n\nGiven a directory structure that looks similar to the earlier Nested Files exercise, but with a slightly different directory structure:\nresults/data\nresults/images\nresults/plots\nresults/analysis\nHow would you ignore all of the contents in the results folder, but not results/data? Hint: think a bit about how you created an exception with the ! operator before.\n\n\n\n\n\n\nSolution\n\n\n\nIf you want to ignore the contents of results/ but not those of results/data/, you can change your .gitignore to ignore the contents of results folder, but create an exception for the contents of the results/data subfolder. Your .gitignore would look like this:\nresults/*               # ignore everything in results folder\n!results/data/          # do not ignore results/data/ contents\n\n\n\n\n\n\n\n\n\n\nIgnoring all data Files in a Directory\n\n\n\nAssuming you have an empty .gitignore file, and given a directory structure that looks like:\nresults/data/position/gps/a.dat\nresults/data/position/gps/b.dat\nresults/data/position/gps/c.dat\nresults/data/position/gps/info.txt\nresults/plots\nWhat’s the shortest .gitignore rule you could write to ignore all .dat files in result/data/position/gps? Do not ignore the info.txt.\n\n\n\n\n\n\nSolution\n\n\n\nAppending results/data/position/gps/*.dat will match every file in results/data/position/gps that ends with .dat. The file results/data/position/gps/info.txt will not be ignored.\n\n\n\n\n\n\n\n\n\n\nIgnoring all data Files in the repository\n\n\n\nLet us assume you have many .dat files in different subdirectories of your repository. For example, you might have:\nresults/a.dat\ndata/experiment_1/b.dat\ndata/experiment_2/c.dat\ndata/experiment_2/variation_1/d.dat\nHow do you ignore all the .dat files, without explicitly listing the names of the corresponding folders?\n\n\n\n\n\n\nSolution\n\n\n\nIn the .gitignore file, write:\n**/*.dat               \nThis will ignore all the .dat files, regardless of their position in the directory tree. You can still include some specific exception with the exclamation point operator.\n\n\n\n\n\n\n\n\n\n\nThe Order of Rules\n\n\n\nGiven a .gitignore file with the following contents:\n*.dat\n!*.dat\nWhat will be the result?\n\n\n\n\n\n\nSolution\n\n\n\nThe ! modifier will negate an entry from a previously defined ignore pattern. Because the !*.dat entry negates all of the previous .dat files in the .gitignore, none of them will be ignored, and all .dat files will be tracked.\n\n\n\n\n\n\n\n\n\n\nLog Files\n\n\n\nYou wrote a script that creates many intermediate log-files of the form log_01, log_02, log_03, etc. You want to keep them but you do not want to track them through git.\n\nWrite one .gitignore entry that excludes files of the form log_01, log_02, etc.\nTest your “ignore pattern” by creating some dummy files of the form log_01, etc.\nYou find that the file log_01 is very important after all, add it to the tracked files without changing the .gitignore again.\nDiscuss with your neighbor what other types of files could reside in your directory that you do not want to track and thus would exclude via .gitignore.\n\n\n\n\n\n\n\nSolution\n\n\n\n\nappend either log_* or log* as a new entry in your .gitignore\ntrack log_01 using git add -f log_01\n\n\n\n\n\n\n\n\nAll materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/04_changes.html",
    "href": "notebooks/04_changes.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/12_pull_requests.html",
    "href": "notebooks/12_pull_requests.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/09_branches.html",
    "href": "notebooks/09_branches.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/03_create.html",
    "href": "notebooks/03_create.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/01_intro.html",
    "href": "notebooks/01_intro.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/00_otherresources.html",
    "href": "notebooks/00_otherresources.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/10_merging.html",
    "href": "notebooks/10_merging.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "Git commits as a data structure\nThe commits which make up the history of a Git repository with multiple branches form a mathematical structure called a directed acyclic graph.\nEach commit is a node in the graph. The graph is directed because every edge links a commit to one or more parents, and this relationship is one-way.\nAnd the graph is acyclic because loops aren’t permitted - if you traverse the graph following a commit’s parents back to the root commit, you won’t pass through any of the same commits twice.\n[ Illustration of a DAG ]\n\n\nFast-forwards\nThese are the simplest merge: where the two commits we are merging have a common shared history. This was the case in the example we just merged. Nothing new had been added to the main branch while Alice was working on her development branch, so there’s no need to work out how to combine the two histories.\nIn these cases, Git can ‘fast-forward’: it simply updates the head of our main branch to the commit at the tip of the develop branch.\n[ picture here of the fast-forward scenario]\nBecause the merge is using commits which already exist, Git doesn’t prompt us for a commit message when it can fast-forward.\n\n\nMerges\nWe are now going to see what happens when we ask git to merge two branches which have diverged: that is, where there are new commits on either branch.\nIn this example,\ngit checkout development\nnano mean.py\nWe then commit this change\ngit add mean.py\ngit commit mean.py -m \"One line near the top\"\nThen, let’s make a change to mean.py on the main branch\ngit checkout main\nnano mean.py\nWe’ll add another line in a different part of the script, save and commit the change.\ngit add mean.py\ngit commit mean.py -m \"One line near the bottom\"\nOur two branches now have different histories: each branch has a commit which doesn’t exist in the other branch.\nWe can compare the two files across branches using git diff\ngit diff development\nFIXME\nOnce again, because this is a diff from development to main, the changes we’ve made in main which aren’t in development show as inserts (+) and the changes in development which aren’t in main show as deletes (-)\nWe can now ask Git to merge the changes from development into our main branch\ngit merge development\nMerge branch 'development'\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\nWhen we do this, git has prompted us for a commit message: this is similar to what we’ve seen earlier when we’ve committed a change, but in this case, git has pre-filled the commit message with Merge branch 'development'\nThe reason git is asking for a message is because merging two branches which have diverged will create a new commit, called a merge commit.\nIn our first merge, because fast-forwarding was possible, there was no need for a merge commit.\nYou have the option here to add a more complicated message explaining why you’re merging, but for now we’ll just accept git’s default message and save:\nAuto-merging mean.py\nMerge made by the 'ort' strategy.\n mean.py | 2 ++\n 1 file changed, 2 insertions(+)\nThis output means that git has successfully merge the two versions of mean.py. Git reports that it’s used the ‘ort’ strategy - historically, git has had a number of different algorithms which it uses to try to combine commits. ‘ort’ is a relatively recent addition: the details of how the different strategies work is not something we can go into today.\nIf we check our log:\ngit log --oneline\nWe can see that this merge has created a new commit, and that the fact that it’s a merge commit is indicated in the history.\nYou can also see that commits from both main and development are now visible in the log.\nLet’s see what the file actually looks like after the merge.\nnano mean.py\nWe can see that git has added the new line from development at the bottom, and kept the new line from main at the top. From Git’s point of view, the merge was a success - it’s managed to bring the divergent histories of this file into one text and kept the features of both.\n[ FIXME - this would be a point to introduce the idea that a merged file could contain bugs and that git can’t check this]\nTODO - some exercises?\n\n\n\n\nAll materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/08_collab.html",
    "href": "notebooks/08_collab.html",
    "title": "Collaborating",
    "section": "",
    "text": "Practicing By Yourself\nIf you’re working through this lesson on your own, you can carry on by opening a second terminal window. This window will represent your partner, working on another computer. You won’t need to give anyone access on GitHub, because both ‘partners’ are you. {: .callout}\n\nThe Owner needs to give the Collaborator access. On GitHub, click the “Settings” button on the right, select “Collaborators”, click “Add people”, and then enter your partner’s username.\n\n\n\nAdding Collaborators on GitHub\n\n\nTo accept access to the Owner’s repo, the Collaborator needs to go to https://github.com/notifications or check for email notification. Once there she can accept access to the Owner’s repo.\nNext, the Collaborator needs to download a copy of the Owner’s repository to her machine. This is called “cloning a repo”.\nThe Collaborator doesn’t want to overwrite her own version of planets.git, so needs to clone the Owner’s repository to a different location than her own repository with the same name.\nTo clone the Owner’s repo into her Desktop folder, the Collaborator enters:\n$ git clone git@github.com:vlad/planets.git ~/Desktop/vlad-planets\n{: .language-bash}\nReplace ‘vlad’ with the Owner’s username.\nIf you choose to clone without the clone path (~/Desktop/vlad-planets) specified at the end, you will clone inside your own planets folder! Make sure to navigate to the Desktop folder first.\n\n\n\nAfter Creating Clone of Repository\n\n\nThe Collaborator can now make a change in her clone of the Owner’s repository, exactly the same way as we’ve been doing before:\n$ cd ~/Desktop/vlad-planets\n$ nano pluto.txt\n$ cat pluto.txt\n{: .language-bash}\nIt is so a planet!\n{: .output}\n$ git add pluto.txt\n$ git commit -m \"Add notes about Pluto\"\n{: .language-bash}\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\n{: .output}\nThen push the change to the Owner’s repository on GitHub:\n$ git push origin main\n{: .language-bash}\nEnumerating objects: 4, done.\nCounting objects: 4, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 306 bytes, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo https://github.com/vlad/planets.git\n   9272da5..29aba7c  main -> main\n{: .output}\nNote that we didn’t have to create a remote called origin: Git uses this name by default when we clone a repository. (This is why origin was a sensible choice earlier when we were setting up remotes by hand.)\nTake a look at the Owner’s repository on GitHub again, and you should be able to see the new commit made by the Collaborator. You may need to refresh your browser to see the new commit.\n\nSome more about remotes\nIn this episode and the previous one, our local repository has had a single “remote”, called origin. A remote is a copy of the repository that is hosted somewhere else, that we can push to and pull from, and there’s no reason that you have to work with only one. For example, on some large projects you might have your own copy in your own GitHub account (you’d probably call this origin) and also the main “upstream” project repository (let’s call this upstream for the sake of examples). You would pull from upstream from time to time to get the latest updates that other people have committed.\nRemember that the name you give to a remote only exists locally. It’s an alias that you choose - whether origin, or upstream, or fred - and not something intrinstic to the remote repository.\nThe git remote family of commands is used to set up and alter the remotes associated with a repository. Here are some of the most useful ones:\n\ngit remote -v lists all the remotes that are configured (we already used this in the last episode)\ngit remote add [name] [url] is used to add a new remote\ngit remote remove [name] removes a remote. Note that it doesn’t affect the remote repository at all - it just removes the link to it from the local repo.\ngit remote set-url [name] [newurl] changes the URL that is associated with the remote. This is useful if it has moved, e.g. to a different GitHub account, or from GitHub to a different hosting service. Or, if we made a typo when adding it!\ngit remote rename [oldname] [newname] changes the local alias by which a remote is known - its name. For example, one could use this to change upstream to fred. {: .callout}\n\n\nTo download the Collaborator’s changes from GitHub, the Owner now enters:\n$ git pull origin main\n{: .language-bash}\nremote: Enumerating objects: 4, done.\nremote: Counting objects: 100% (4/4), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/vlad/planets\n * branch            main     -> FETCH_HEAD\n   9272da5..29aba7c  main     -> origin/main\nUpdating 9272da5..29aba7c\nFast-forward\n pluto.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\n{: .output}\nNow the three repositories (Owner’s local, Collaborator’s local, and Owner’s on GitHub) are back in sync.\n\nA Basic Collaborative Workflow\nIn practice, it is good to be sure that you have an updated version of the repository you are collaborating on, so you should git pull before making our changes. The basic collaborative workflow would be:\n\nupdate your local repo with git pull origin main,\nmake your changes and stage them with git add,\ncommit your changes with git commit -m, and\nupload the changes to GitHub with git push origin main\n\nIt is better to make many commits with smaller changes rather than of one commit with massive changes: small commits are easier to read and review. {: .callout}\n\n\nSwitch Roles and Repeat\nSwitch roles and repeat the whole process. {: .challenge}\n\n\nReview Changes\nThe Owner pushed commits to the repository without giving any information to the Collaborator. How can the Collaborator find out what has changed with command line? And on GitHub?\n\nSolution\nOn the command line, the Collaborator can use git fetch origin main to get the remote changes into the local repository, but without merging them. Then by running git diff main origin/main the Collaborator will see the changes output in the terminal.\nOn GitHub, the Collaborator can go to the repository and click on “commits” to view the most recent commits pushed to the repository. {: .solution} {: .challenge}\n\n\n\nComment Changes in GitHub\nThe Collaborator has some questions about one line change made by the Owner and has some suggestions to propose.\nWith GitHub, it is possible to comment on the diff of a commit. Over the line of code to comment, a blue comment icon appears to open a comment window.\nThe Collaborator posts her comments and suggestions using the GitHub interface. {: .challenge}\n\n\nVersion History, Backup, and Version Control\nSome backup software can keep a history of the versions of your files. They also allows you to recover specific versions. How is this functionality different from version control? What are some of the benefits of using version control, Git and GitHub? {: .challenge}\n\n\n\n\nAll materials copyright Sydney Informatics Hub, University of Sydney"
  },
  {
    "objectID": "notebooks/13_conflicts.html",
    "href": "notebooks/13_conflicts.html",
    "title": "SIH Introduction to Version Control using Git",
    "section": "",
    "text": "All materials copyright Sydney Informatics Hub, University of Sydney"
  }
]